// Code generated by go-swagger; DO NOT EDIT.

package auth

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new auth API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for auth API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AllUserLoginLockouts gets all user login lockouts

### Get currently locked-out users.

*/
func (a *Client) AllUserLoginLockouts(params *AllUserLoginLockoutsParams) (*AllUserLoginLockoutsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAllUserLoginLockoutsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "all_user_login_lockouts",
		Method:             "GET",
		PathPattern:        "/user_login_lockouts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AllUserLoginLockoutsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AllUserLoginLockoutsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for all_user_login_lockouts: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateOidcTestConfig creates o ID c test configuration

### Create a OIDC test configuration.

*/
func (a *Client) CreateOidcTestConfig(params *CreateOidcTestConfigParams) (*CreateOidcTestConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateOidcTestConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "create_oidc_test_config",
		Method:             "POST",
		PathPattern:        "/oidc_test_configs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateOidcTestConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateOidcTestConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for create_oidc_test_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateSamlTestConfig creates s a m l test configuration

### Create a SAML test configuration.

*/
func (a *Client) CreateSamlTestConfig(params *CreateSamlTestConfigParams) (*CreateSamlTestConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSamlTestConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "create_saml_test_config",
		Method:             "POST",
		PathPattern:        "/saml_test_configs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateSamlTestConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateSamlTestConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for create_saml_test_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateSsoEmbedURL creates s s o embed Url

### Create SSO Embed URL

Creates an SSO embed URL and cryptographically signs it with an embed secret.
This signed URL can then be used to instantiate a Looker embed session in a PBL web application.
Do not make any modifications to this URL - any change may invalidate the signature and
cause the URL to fail to load a Looker embed session.

A signed SSO embed URL can only be used once. After it has been used to request a page from the
Looker server, the URL is invalid. Future requests using the same URL will fail. This is to prevent
'replay attacks'.

The `target_url` property must be a complete URL of a Looker UI page - scheme, hostname, path and query params.
To load a dashboard with id 56 and with a filter of `Date=1 years`, the looker URL would look like `https:/myname.looker.com/dashboards/56?Date=1%20years`.
The best way to obtain this target_url is to navigate to the desired Looker page in your web browser,
copy the URL shown in the browser address bar and paste it into the `target_url` property as a quoted string value in this API request.

Permissions for the embed user are defined by the groups in which the embed user is a member (group_ids property)
and the lists of models and permissions assigned to the embed user.
At a minimum, you must provide values for either the group_ids property, or both the models and permissions properties.
These properties are additive; an embed user can be a member of certain groups AND be granted access to models and permissions.

The embed user's access is the union of permissions granted by the group_ids, models, and permissions properties.

This function does not strictly require all group_ids, user attribute names, or model names to exist at the moment the
SSO embed url is created. Unknown group_id, user attribute names or model names will be passed through to the output URL.
To diagnose potential problems with an SSO embed URL, you can copy the signed URL into the Embed URI Validator text box in `<your looker instance>/admin/embed`.

The `secret_id` parameter is optional. If specified, its value must be the id of an active secret defined in the Looker instance.
if not specified, the URL will be signed using the newest active secret defined in the Looker instance.

#### Security Note
Protect this signed URL as you would an access token or password credentials - do not write
it to disk, do not pass it to a third party, and only pass it through a secure HTTPS
encrypted transport.

*/
func (a *Client) CreateSsoEmbedURL(params *CreateSsoEmbedURLParams) (*CreateSsoEmbedURLOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSsoEmbedURLParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "create_sso_embed_url",
		Method:             "POST",
		PathPattern:        "/embed/sso_url",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateSsoEmbedURLReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateSsoEmbedURLOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for create_sso_embed_url: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteOidcTestConfig deletes o ID c test configuration

### Delete a OIDC test configuration.

*/
func (a *Client) DeleteOidcTestConfig(params *DeleteOidcTestConfigParams) (*DeleteOidcTestConfigNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteOidcTestConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_oidc_test_config",
		Method:             "DELETE",
		PathPattern:        "/oidc_test_configs/{test_slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteOidcTestConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteOidcTestConfigNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for delete_oidc_test_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteSamlTestConfig deletes s a m l test configuration

### Delete a SAML test configuration.

*/
func (a *Client) DeleteSamlTestConfig(params *DeleteSamlTestConfigParams) (*DeleteSamlTestConfigNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSamlTestConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_saml_test_config",
		Method:             "DELETE",
		PathPattern:        "/saml_test_configs/{test_slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteSamlTestConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteSamlTestConfigNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for delete_saml_test_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteUserLoginLockout deletes user login lockout

### Removes login lockout for the associated user.

*/
func (a *Client) DeleteUserLoginLockout(params *DeleteUserLoginLockoutParams) (*DeleteUserLoginLockoutNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUserLoginLockoutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_user_login_lockout",
		Method:             "DELETE",
		PathPattern:        "/user_login_lockout/{key}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteUserLoginLockoutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteUserLoginLockoutNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for delete_user_login_lockout: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FetchAndParseSamlIdpMetadata parses s a m l Id p Url

### Fetch the given url and parse it as a SAML IdP metadata document and return the result.
Note that this requires that the url be public or at least at a location where the Looker instance
can fetch it without requiring any special authentication.

*/
func (a *Client) FetchAndParseSamlIdpMetadata(params *FetchAndParseSamlIdpMetadataParams) (*FetchAndParseSamlIdpMetadataOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFetchAndParseSamlIdpMetadataParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "fetch_and_parse_saml_idp_metadata",
		Method:             "POST",
		PathPattern:        "/fetch_and_parse_saml_idp_metadata",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"text/plain"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FetchAndParseSamlIdpMetadataReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FetchAndParseSamlIdpMetadataOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for fetch_and_parse_saml_idp_metadata: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ForcePasswordResetAtNextLoginForAllUsers forces password reset

### Force all credentials_email users to reset their login passwords upon their next login.

*/
func (a *Client) ForcePasswordResetAtNextLoginForAllUsers(params *ForcePasswordResetAtNextLoginForAllUsersParams) (*ForcePasswordResetAtNextLoginForAllUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewForcePasswordResetAtNextLoginForAllUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "force_password_reset_at_next_login_for_all_users",
		Method:             "PUT",
		PathPattern:        "/password_config/force_password_reset_at_next_login_for_all_users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ForcePasswordResetAtNextLoginForAllUsersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ForcePasswordResetAtNextLoginForAllUsersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for force_password_reset_at_next_login_for_all_users: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LdapConfig gets l d a p configuration

### Get the LDAP configuration.

Looker can be optionally configured to authenticate users against an Active Directory or other LDAP directory server.
LDAP setup requires coordination with an administrator of that directory server.

Only Looker administrators can read and update the LDAP configuration.

Configuring LDAP impacts authentication for all users. This configuration should be done carefully.

Looker maintains a single LDAP configuration. It can be read and updated.       Updates only succeed if the new state will be valid (in the sense that all required fields are populated);       it is up to you to ensure that the configuration is appropriate and correct).

LDAP is enabled or disabled for Looker using the **enabled** field.

Looker will never return an **auth_password** field. That value can be set, but never retrieved.

See the [Looker LDAP docs](https://www.looker.com/docs/r/api/ldap_setup) for additional information.

*/
func (a *Client) LdapConfig(params *LdapConfigParams) (*LdapConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLdapConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ldap_config",
		Method:             "GET",
		PathPattern:        "/ldap_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LdapConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LdapConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ldap_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OidcConfig gets o ID c configuration

### Get the OIDC configuration.

Looker can be optionally configured to authenticate users against an OpenID Connect (OIDC)
authentication server. OIDC setup requires coordination with an administrator of that server.

Only Looker administrators can read and update the OIDC configuration.

Configuring OIDC impacts authentication for all users. This configuration should be done carefully.

Looker maintains a single OIDC configuation. It can be read and updated.       Updates only succeed if the new state will be valid (in the sense that all required fields are populated);       it is up to you to ensure that the configuration is appropriate and correct).

OIDC is enabled or disabled for Looker using the **enabled** field.

*/
func (a *Client) OidcConfig(params *OidcConfigParams) (*OidcConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOidcConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "oidc_config",
		Method:             "GET",
		PathPattern:        "/oidc_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OidcConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OidcConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for oidc_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OidcTestConfig gets o ID c test configuration

### Get a OIDC test configuration by test_slug.

*/
func (a *Client) OidcTestConfig(params *OidcTestConfigParams) (*OidcTestConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOidcTestConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "oidc_test_config",
		Method:             "GET",
		PathPattern:        "/oidc_test_configs/{test_slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OidcTestConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OidcTestConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for oidc_test_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ParseSamlIdpMetadata parses s a m l Id p XML

### Parse the given xml as a SAML IdP metadata document and return the result.

*/
func (a *Client) ParseSamlIdpMetadata(params *ParseSamlIdpMetadataParams) (*ParseSamlIdpMetadataOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewParseSamlIdpMetadataParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "parse_saml_idp_metadata",
		Method:             "POST",
		PathPattern:        "/parse_saml_idp_metadata",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"text/plain"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ParseSamlIdpMetadataReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ParseSamlIdpMetadataOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for parse_saml_idp_metadata: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PasswordConfig gets password config

### Get password config.

*/
func (a *Client) PasswordConfig(params *PasswordConfigParams) (*PasswordConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPasswordConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "password_config",
		Method:             "GET",
		PathPattern:        "/password_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PasswordConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PasswordConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for password_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SamlConfig gets s a m l configuration

### Get the SAML configuration.

Looker can be optionally configured to authenticate users against a SAML authentication server.
SAML setup requires coordination with an administrator of that server.

Only Looker administrators can read and update the SAML configuration.

Configuring SAML impacts authentication for all users. This configuration should be done carefully.

Looker maintains a single SAML configuation. It can be read and updated.       Updates only succeed if the new state will be valid (in the sense that all required fields are populated);       it is up to you to ensure that the configuration is appropriate and correct).

SAML is enabled or disabled for Looker using the **enabled** field.

*/
func (a *Client) SamlConfig(params *SamlConfigParams) (*SamlConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "saml_config",
		Method:             "GET",
		PathPattern:        "/saml_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SamlConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SamlConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for saml_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SamlTestConfig gets s a m l test configuration

### Get a SAML test configuration by test_slug.

*/
func (a *Client) SamlTestConfig(params *SamlTestConfigParams) (*SamlTestConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlTestConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "saml_test_config",
		Method:             "GET",
		PathPattern:        "/saml_test_configs/{test_slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SamlTestConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SamlTestConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for saml_test_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SearchUserLoginLockouts searches user login lockouts

### Search currently locked-out users.

*/
func (a *Client) SearchUserLoginLockouts(params *SearchUserLoginLockoutsParams) (*SearchUserLoginLockoutsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSearchUserLoginLockoutsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "search_user_login_lockouts",
		Method:             "GET",
		PathPattern:        "/user_login_lockouts/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SearchUserLoginLockoutsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SearchUserLoginLockoutsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for search_user_login_lockouts: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SessionConfig gets session config

### Get session config.

*/
func (a *Client) SessionConfig(params *SessionConfigParams) (*SessionConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSessionConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "session_config",
		Method:             "GET",
		PathPattern:        "/session_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SessionConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SessionConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for session_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
TestLdapConfigAuth tests l d a p auth

### Test the connection authentication settings for an LDAP configuration.

This tests that the connection is possible and that a 'server' account to be used by Looker can       authenticate to the LDAP server given connection and authentication information.

**connection_host**, **connection_port**, and **auth_username**, are required.       **connection_tls** and **auth_password** are optional.

Example:
```json
{
  "connection_host": "ldap.example.com",
  "connection_port": "636",
  "connection_tls": true,
  "auth_username": "cn=looker,dc=example,dc=com",
  "auth_password": "secret"
}
```

Looker will never return an **auth_password**. If this request omits the **auth_password** field, then       the **auth_password** value from the active config (if present) will be used for the test.

The active LDAP settings are not modified.


*/
func (a *Client) TestLdapConfigAuth(params *TestLdapConfigAuthParams) (*TestLdapConfigAuthOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestLdapConfigAuthParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "test_ldap_config_auth",
		Method:             "PUT",
		PathPattern:        "/ldap_config/test_auth",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestLdapConfigAuthReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*TestLdapConfigAuthOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for test_ldap_config_auth: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
TestLdapConfigConnection tests l d a p connection

### Test the connection settings for an LDAP configuration.

This tests that the connection is possible given a connection_host and connection_port.

**connection_host** and **connection_port** are required. **connection_tls** is optional.

Example:
```json
{
  "connection_host": "ldap.example.com",
  "connection_port": "636",
  "connection_tls": true
}
```

No authentication to the LDAP server is attempted.

The active LDAP settings are not modified.

*/
func (a *Client) TestLdapConfigConnection(params *TestLdapConfigConnectionParams) (*TestLdapConfigConnectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestLdapConfigConnectionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "test_ldap_config_connection",
		Method:             "PUT",
		PathPattern:        "/ldap_config/test_connection",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestLdapConfigConnectionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*TestLdapConfigConnectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for test_ldap_config_connection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
TestLdapConfigUserAuth tests l d a p user auth

### Test the user authentication settings for an LDAP configuration.

This test accepts a full LDAP configuration along with a username/password pair and attempts to       authenticate the user with the LDAP server. The configuration is validated before attempting the       authentication.

Looker will never return an **auth_password**. If this request omits the **auth_password** field, then       the **auth_password** value from the active config (if present) will be used for the test.

**test_ldap_user** and **test_ldap_password** are required.

The active LDAP settings are not modified.


*/
func (a *Client) TestLdapConfigUserAuth(params *TestLdapConfigUserAuthParams) (*TestLdapConfigUserAuthOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestLdapConfigUserAuthParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "test_ldap_config_user_auth",
		Method:             "PUT",
		PathPattern:        "/ldap_config/test_user_auth",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestLdapConfigUserAuthReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*TestLdapConfigUserAuthOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for test_ldap_config_user_auth: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
TestLdapConfigUserInfo tests l d a p user info

### Test the user authentication settings for an LDAP configuration without authenticating the user.

This test will let you easily test the mapping for user properties and roles for any user without      needing to authenticate as that user.

This test accepts a full LDAP configuration along with a username and attempts to find the full info      for the user from the LDAP server without actually authenticating the user. So, user password is not      required.The configuration is validated before attempting to contact the server.

**test_ldap_user** is required.

The active LDAP settings are not modified.


*/
func (a *Client) TestLdapConfigUserInfo(params *TestLdapConfigUserInfoParams) (*TestLdapConfigUserInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestLdapConfigUserInfoParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "test_ldap_config_user_info",
		Method:             "PUT",
		PathPattern:        "/ldap_config/test_user_info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestLdapConfigUserInfoReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*TestLdapConfigUserInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for test_ldap_config_user_info: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateLdapConfig updates l d a p configuration

### Update the LDAP configuration.

Configuring LDAP impacts authentication for all users. This configuration should be done carefully.

Only Looker administrators can read and update the LDAP configuration.

LDAP is enabled or disabled for Looker using the **enabled** field.

It is **highly** recommended that any LDAP setting changes be tested using the APIs below before being set globally.

See the [Looker LDAP docs](https://www.looker.com/docs/r/api/ldap_setup) for additional information.

*/
func (a *Client) UpdateLdapConfig(params *UpdateLdapConfigParams) (*UpdateLdapConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateLdapConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "update_ldap_config",
		Method:             "PATCH",
		PathPattern:        "/ldap_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateLdapConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateLdapConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for update_ldap_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateOidcConfig updates o ID c configuration

### Update the OIDC configuration.

Configuring OIDC impacts authentication for all users. This configuration should be done carefully.

Only Looker administrators can read and update the OIDC configuration.

OIDC is enabled or disabled for Looker using the **enabled** field.

It is **highly** recommended that any OIDC setting changes be tested using the APIs below before being set globally.

*/
func (a *Client) UpdateOidcConfig(params *UpdateOidcConfigParams) (*UpdateOidcConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateOidcConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "update_oidc_config",
		Method:             "PATCH",
		PathPattern:        "/oidc_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateOidcConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateOidcConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for update_oidc_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdatePasswordConfig updates password config

### Update password config.

*/
func (a *Client) UpdatePasswordConfig(params *UpdatePasswordConfigParams) (*UpdatePasswordConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePasswordConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "update_password_config",
		Method:             "PATCH",
		PathPattern:        "/password_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdatePasswordConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdatePasswordConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for update_password_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateSamlConfig updates s a m l configuration

### Update the SAML configuration.

Configuring SAML impacts authentication for all users. This configuration should be done carefully.

Only Looker administrators can read and update the SAML configuration.

SAML is enabled or disabled for Looker using the **enabled** field.

It is **highly** recommended that any SAML setting changes be tested using the APIs below before being set globally.

*/
func (a *Client) UpdateSamlConfig(params *UpdateSamlConfigParams) (*UpdateSamlConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSamlConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "update_saml_config",
		Method:             "PATCH",
		PathPattern:        "/saml_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateSamlConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateSamlConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for update_saml_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateSessionConfig updates session config

### Update session config.

*/
func (a *Client) UpdateSessionConfig(params *UpdateSessionConfigParams) (*UpdateSessionConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSessionConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "update_session_config",
		Method:             "PATCH",
		PathPattern:        "/session_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateSessionConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateSessionConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for update_session_config: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
