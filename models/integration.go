// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// Integration integration
// swagger:model Integration
type Integration struct {

	// Operations the current user is able to perform on this object
	// Read Only: true
	Can map[string]bool `json:"can,omitempty"`

	// Description of the integration.
	// Read Only: true
	Description string `json:"description,omitempty"`

	// Whether the integration is available to users.
	Enabled bool `json:"enabled,omitempty"`

	// URL to an icon for the integration.
	// Read Only: true
	IconURL string `json:"icon_url,omitempty"`

	// ID of the integration.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// ID of the integration hub.
	// Read Only: true
	IntegrationHubID int64 `json:"integration_hub_id,omitempty"`

	// Label for the integration.
	// Read Only: true
	Label string `json:"label,omitempty"`

	// Array of params for the integration.
	Params []*IntegrationParam `json:"params"`

	// A list of descriptions of required fields that this integration is compatible with. If there are multiple entries in this list, the integration requires more than one field. If unspecified, no fields will be required.
	// Read Only: true
	RequiredFields []*IntegrationRequiredField `json:"required_fields"`

	// A list of action types the integration supports. Valid values are: "cell", "query", "dashboard".
	// Read Only: true
	SupportedActionTypes []string `json:"supported_action_types"`

	// A list of all the download mechanisms the integration supports. The order is undefined: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this will default to ["push"]. Valid values are: "push", "url".
	// Read Only: true
	SupportedDownloadSettings []string `json:"supported_download_settings"`

	// A list of data formats the integration supports. If unspecified, this will default to ["txt", "csv", "inline_json", "json", "json_detail", "json_detail_lite_stream", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip"]. Valid values are: "txt", "csv", "inline_json", "json", "json_detail", "json_detail_lite_stream", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip".
	// Read Only: true
	SupportedFormats []string `json:"supported_formats"`

	// A list of formatting options the integration supports. If unspecified, this will default to ["formatted", "unformatted"]. Valid values are: "formatted", "unformatted".
	// Read Only: true
	SupportedFormattings []string `json:"supported_formattings"`

	// A list of visualization formatting options the integration supports. If unspecified, this will default to ["apply", "noapply"]. Valid values are: "apply", "noapply".
	// Read Only: true
	SupportedVisualizationFormattings []string `json:"supported_visualization_formattings"`
}

// Validate validates this integration
func (m *Integration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequiredFields(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Integration) validateParams(formats strfmt.Registry) error {

	if swag.IsZero(m.Params) { // not required
		return nil
	}

	for i := 0; i < len(m.Params); i++ {
		if swag.IsZero(m.Params[i]) { // not required
			continue
		}

		if m.Params[i] != nil {
			if err := m.Params[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("params" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Integration) validateRequiredFields(formats strfmt.Registry) error {

	if swag.IsZero(m.RequiredFields) { // not required
		return nil
	}

	for i := 0; i < len(m.RequiredFields); i++ {
		if swag.IsZero(m.RequiredFields[i]) { // not required
			continue
		}

		if m.RequiredFields[i] != nil {
			if err := m.RequiredFields[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("required_fields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Integration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Integration) UnmarshalBinary(b []byte) error {
	var res Integration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
