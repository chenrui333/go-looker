// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LDAPConfig l d a p config
// swagger:model LDAPConfig
type LDAPConfig struct {

	// Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
	AlternateEmailLoginAllowed bool `json:"alternate_email_login_allowed,omitempty"`

	// (Write-Only)  Password for the LDAP account used to access the LDAP server
	AuthPassword string `json:"auth_password,omitempty"`

	// Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
	AuthRequiresRole bool `json:"auth_requires_role,omitempty"`

	// Distinguished name of LDAP account used to access the LDAP server
	AuthUsername string `json:"auth_username,omitempty"`

	// Operations the current user is able to perform on this object
	// Read Only: true
	Can map[string]bool `json:"can,omitempty"`

	// LDAP server hostname
	ConnectionHost string `json:"connection_host,omitempty"`

	// LDAP host port
	ConnectionPort string `json:"connection_port,omitempty"`

	// Use Transport Layer Security
	ConnectionTLS bool `json:"connection_tls,omitempty"`

	// Do not verify peer when using TLS
	ConnectionTLSNoVerify bool `json:"connection_tls_no_verify,omitempty"`

	// (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
	DefaultNewUserGroupIds []int64 `json:"default_new_user_group_ids"`

	// (Read-only) Groups that will be applied to new users the first time they login via LDAP
	// Read Only: true
	DefaultNewUserGroups []*Group `json:"default_new_user_groups"`

	// (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
	DefaultNewUserRoleIds []int64 `json:"default_new_user_role_ids"`

	// (Read-only) Roles that will be applied to new users the first time they login via LDAP
	// Read Only: true
	DefaultNewUserRoles []*Role `json:"default_new_user_roles"`

	// Enable/Disable LDAP authentication for the server
	Enabled bool `json:"enabled,omitempty"`

	// Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
	ForceNoPage bool `json:"force_no_page,omitempty"`

	// (Read-only) Array of mappings between LDAP Groups and Looker Roles
	// Read Only: true
	Groups []*LDAPGroupRead `json:"groups"`

	// Base dn for finding groups in LDAP searches
	GroupsBaseDn string `json:"groups_base_dn,omitempty"`

	// Identifier for a strategy for how Looker will search for groups in the LDAP server
	GroupsFinderType string `json:"groups_finder_type,omitempty"`

	// LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
	GroupsMemberAttribute string `json:"groups_member_attribute,omitempty"`

	// Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
	GroupsObjectclasses string `json:"groups_objectclasses,omitempty"`

	// LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
	GroupsUserAttribute string `json:"groups_user_attribute,omitempty"`

	// (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
	GroupsWithRoleIds []*LDAPGroupWrite `json:"groups_with_role_ids"`

	// (Read-only) Has the password been set for the LDAP account used to access the LDAP server
	// Read Only: true
	HasAuthPassword *bool `json:"has_auth_password,omitempty"`

	// Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
	MergeNewUsersByEmail bool `json:"merge_new_users_by_email,omitempty"`

	// When this config was last modified
	// Read Only: true
	ModifiedAt string `json:"modified_at,omitempty"`

	// User id of user who last modified this config
	// Read Only: true
	ModifiedBy string `json:"modified_by,omitempty"`

	// Set user roles in Looker based on groups from LDAP
	SetRolesFromGroups bool `json:"set_roles_from_groups,omitempty"`

	// (Write-Only)  Test LDAP user password. For ldap tests only.
	TestLdapPassword string `json:"test_ldap_password,omitempty"`

	// (Write-Only)  Test LDAP user login id. For ldap tests only.
	TestLdapUser string `json:"test_ldap_user,omitempty"`

	// Link to get this item
	// Read Only: true
	// Format: uri
	URL strfmt.URI `json:"url,omitempty"`

	// Name of user record attributes used to indicate email address field
	UserAttributeMapEmail string `json:"user_attribute_map_email,omitempty"`

	// Name of user record attributes used to indicate first name
	UserAttributeMapFirstName string `json:"user_attribute_map_first_name,omitempty"`

	// Name of user record attributes used to indicate last name
	UserAttributeMapLastName string `json:"user_attribute_map_last_name,omitempty"`

	// Name of user record attributes used to indicate unique record id
	UserAttributeMapLdapID string `json:"user_attribute_map_ldap_id,omitempty"`

	// (Read-only) Array of mappings between LDAP User Attributes and Looker User Attributes
	// Read Only: true
	UserAttributes []*LDAPUserAttributeRead `json:"user_attributes"`

	// (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
	UserAttributesWithIds []*LDAPUserAttributeWrite `json:"user_attributes_with_ids"`

	// Distinguished name of LDAP node used as the base for user searches
	UserBindBaseDn string `json:"user_bind_base_dn,omitempty"`

	// (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
	UserCustomFilter string `json:"user_custom_filter,omitempty"`

	// Name(s) of user record attributes used for matching user login id (comma separated list)
	UserIDAttributeNames string `json:"user_id_attribute_names,omitempty"`

	// (Optional) Name of user record objectclass used for finding user during login id
	UserObjectclass string `json:"user_objectclass,omitempty"`
}

// Validate validates this l d a p config
func (m *LDAPConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefaultNewUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultNewUserRoles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupsWithRoleIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAttributesWithIds(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LDAPConfig) validateDefaultNewUserGroups(formats strfmt.Registry) error {

	if swag.IsZero(m.DefaultNewUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.DefaultNewUserGroups); i++ {
		if swag.IsZero(m.DefaultNewUserGroups[i]) { // not required
			continue
		}

		if m.DefaultNewUserGroups[i] != nil {
			if err := m.DefaultNewUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("default_new_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LDAPConfig) validateDefaultNewUserRoles(formats strfmt.Registry) error {

	if swag.IsZero(m.DefaultNewUserRoles) { // not required
		return nil
	}

	for i := 0; i < len(m.DefaultNewUserRoles); i++ {
		if swag.IsZero(m.DefaultNewUserRoles[i]) { // not required
			continue
		}

		if m.DefaultNewUserRoles[i] != nil {
			if err := m.DefaultNewUserRoles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("default_new_user_roles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LDAPConfig) validateGroups(formats strfmt.Registry) error {

	if swag.IsZero(m.Groups) { // not required
		return nil
	}

	for i := 0; i < len(m.Groups); i++ {
		if swag.IsZero(m.Groups[i]) { // not required
			continue
		}

		if m.Groups[i] != nil {
			if err := m.Groups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LDAPConfig) validateGroupsWithRoleIds(formats strfmt.Registry) error {

	if swag.IsZero(m.GroupsWithRoleIds) { // not required
		return nil
	}

	for i := 0; i < len(m.GroupsWithRoleIds); i++ {
		if swag.IsZero(m.GroupsWithRoleIds[i]) { // not required
			continue
		}

		if m.GroupsWithRoleIds[i] != nil {
			if err := m.GroupsWithRoleIds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups_with_role_ids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LDAPConfig) validateURL(formats strfmt.Registry) error {

	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := validate.FormatOf("url", "body", "uri", m.URL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LDAPConfig) validateUserAttributes(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.UserAttributes); i++ {
		if swag.IsZero(m.UserAttributes[i]) { // not required
			continue
		}

		if m.UserAttributes[i] != nil {
			if err := m.UserAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("user_attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LDAPConfig) validateUserAttributesWithIds(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAttributesWithIds) { // not required
		return nil
	}

	for i := 0; i < len(m.UserAttributesWithIds); i++ {
		if swag.IsZero(m.UserAttributesWithIds[i]) { // not required
			continue
		}

		if m.UserAttributesWithIds[i] != nil {
			if err := m.UserAttributesWithIds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("user_attributes_with_ids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *LDAPConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LDAPConfig) UnmarshalBinary(b []byte) error {
	var res LDAPConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
